"""
Malware Analysis Agent
=====================

Specialized agent for analyzing malware samples using
static and dynamic analysis techniques
"""

import asyncio
import hashlib
import json
import os
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple
import pefile
import yara
import ssdeep
import capstone
from elftools.elf.elffile import ELFFile

from .base_agent import BaseAgent, AgentCapabilities
from ..utils.sandbox import Sandbox
from ..utils.disassembler import Disassembler


class MalwareAnalysisAgent(BaseAgent):
    """
    Advanced malware analysis agent with capabilities:
    - Static analysis (PE/ELF/Mach-O)
    - Dynamic analysis (sandboxing)
    - Code disassembly and analysis
    - Behavioral analysis
    - Network communication analysis
    - Anti-analysis technique detection
    - Similarity analysis
    """
    
    def __init__(self):
        super().__init__("MalwareAnalysisAgent", "2.0.0")
        self.yara_rules = None
        self.sandbox = None
        self.disassembler = None
        
    def _define_capabilities(self) -> AgentCapabilities:
        return AgentCapabilities(
            evidence_types=["malware_sample", "executable", "dll", "script"],
            analysis_types=[
                "static_analysis",
                "dynamic_analysis",
                "code_analysis",
                "behavioral_analysis",
                "network_analysis",
                "anti_analysis_detection",
                "similarity_analysis"
            ],
            required_tools=["yara", "capstone", "cuckoo", "radare2"],
            parallel_capable=False,  # Sandbox analysis should be sequential
            gpu_accelerated=True
        )
    
    async def _setup(self):
        """Initialize malware analysis tools"""
        # Load YARA rules
        self.yara_rules = await self._load_yara_rules()
        
        # Initialize sandbox
        self.sandbox = Sandbox()
        await self.sandbox.initialize()
        
        # Initialize disassembler
        self.disassembler = Disassembler()
    
    async def _load_yara_rules(self) -> yara.Rules:
        """Load YARA rules for malware detection"""
        rules_path = Path(__file__).parent.parent / "rules" / "malware"
        rules_path.mkdir(parents=True, exist_ok=True)
        
        # Create comprehensive malware rules if they don't exist
        await self._create_malware_yara_rules(rules_path)
        
        rule_files = list(rules_path.glob("*.yar"))
        filepaths = {str(f.stem): str(f) for f in rule_files}
        return yara.compile(filepaths=filepaths)
    
    async def _create_malware_yara_rules(self, rules_path: Path):
        """Create comprehensive YARA rules for malware families"""
        rules = {
            "packers.yar": """
rule UPX_Packer
{
    meta:
        description = "Detects UPX packed executables"
        category = "packer"
        
    strings:
        $upx1 = {55 50 58 21}
        $upx2 = "UPX!"
        $upx3 = {55 50 58 30}
        
    condition:
        uint16(0) == 0x5A4D and any of them
}

rule VMProtect_Packer
{
    meta:
        description = "Detects VMProtect packed executables"
        category = "packer"
        
    strings:
        $vmp1 = ".vmp0"
        $vmp2 = ".vmp1"
        $vmp3 = ".vmp2"
        
    condition:
        uint16(0) == 0x5A4D and any of them
}
""",
            "anti_analysis.yar": """
rule Anti_Debug_Techniques
{
    meta:
        description = "Detects anti-debugging techniques"
        category = "anti-analysis"
        
    strings:
        $api1 = "IsDebuggerPresent"
        $api2 = "CheckRemoteDebuggerPresent"
        $api3 = "NtQueryInformationProcess"
        $api4 = "OutputDebugString"
        $peb = {64 A1 30 00 00 00}  // mov eax, fs:[30h]
        
    condition:
        2 of them
}

rule Anti_VM_Techniques
{
    meta:
        description = "Detects anti-VM techniques"
        category = "anti-analysis"
        
    strings:
        $vm1 = "VMware"
        $vm2 = "VirtualBox"
        $vm3 = "QEMU"
        $vm4 = "Xen"
        $reg1 = "SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum"
        $reg2 = "HARDWARE\\Description\\System"
        
    condition:
        2 of them
}
""",
            "ransomware.yar": """
rule Generic_Ransomware
{
    meta:
        description = "Generic ransomware indicators"
        category = "ransomware"
        severity = "critical"
        
    strings:
        $s1 = "Your files have been encrypted"
        $s2 = "All your files"
        $s3 = "pay the ransom"
        $s4 = "bitcoin address"
        $s5 = "decrypt your files"
        $crypto1 = "CryptEncrypt"
        $crypto2 = "CryptGenKey"
        $crypto3 = "CryptAcquireContext"
        $ext1 = ".locked"
        $ext2 = ".encrypted"
        
    condition:
        3 of ($s*) or (2 of ($crypto*) and 1 of ($ext*))
}

rule WannaCry_Ransomware
{
    meta:
        description = "WannaCry ransomware"
        category = "ransomware"
        family = "WannaCry"
        
    strings:
        $s1 = "WNcry@2ol7"
        $s2 = "iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com"
        $s3 = "mssecsvc.exe"
        
    condition:
        any of them
}
""",
            "trojans.yar": """
rule Remote_Access_Trojan
{
    meta:
        description = "Generic RAT indicators"
        category = "trojan"
        
    strings:
        $cmd1 = "cmd.exe /c"
        $cmd2 = "powershell.exe"
        $net1 = "WSAStartup"
        $net2 = "connect"
        $net3 = "send"
        $net4 = "recv"
        $reg1 = "RegSetValueEx"
        $proc1 = "CreateProcess"
        $proc2 = "CreateRemoteThread"
        
    condition:
        5 of them
}

rule Emotet_Trojan
{
    meta:
        description = "Emotet banking trojan"
        category = "trojan"
        family = "Emotet"
        
    strings:
        $s1 = {C7 ?? ?? ?? ?? ?? E8 ?? ?? ?? ?? 83 ?? ?? 75}
        $s2 = "urlmon.dll"
        $s3 = "URLDownloadToFile"
        
    condition:
        all of them
}
"""
        }
        
        for filename, content in rules.items():
            rule_file = rules_path / filename
            if not rule_file.exists():
                with open(rule_file, 'w') as f:
                    f.write(content)
    
    async def analyze(self, evidence_data: Dict[str, Any], 
                     case_context: Any) -> Dict[str, Any]:
        """Perform comprehensive malware analysis"""
        if not await self.validate_evidence(evidence_data):
            return {"error": "Invalid evidence type for malware analysis"}
        
        self.logger.info(f"Starting malware analysis for {evidence_data['id']}")
        
        sample_path = Path(evidence_data['path'])
        results = {
            'agent': self.name,
            'version': self.version,
            'analysis_start': datetime.now().isoformat(),
            'evidence_id': evidence_data['id'],
            'sample_info': await self._get_sample_info(sample_path),
            'findings': {}
        }
        
        # Run analyses
        analysis_tasks = [
            self._static_analysis(sample_path),
            self._code_analysis(sample_path),
            self._anti_analysis_detection(sample_path),
            self._similarity_analysis(sample_path)
        ]
        
        # Run static analyses in parallel
        static_results = await asyncio.gather(*analysis_tasks, return_exceptions=True)
        
        analysis_names = [
            'static_analysis',
            'code_analysis',
            'anti_analysis_detection',
            'similarity_analysis'
        ]
        
        for name, result in zip(analysis_names, static_results):
            if isinstance(result, Exception):
                self.logger.error(f"{name} failed: {result}")
                results['findings'][name] = {'error': str(result)}
            else:
                results['findings'][name] = result
        
        # Run dynamic analysis (sandboxing) - should be done carefully
        if self._is_safe_to_sandbox(results['findings']):
            try:
                dynamic_results = await self._dynamic_analysis(sample_path)
                results['findings']['dynamic_analysis'] = dynamic_results
                
                # Extract behavioral and network analysis from dynamic results
                results['findings']['behavioral_analysis'] = await self._extract_behavioral_analysis(dynamic_results)
                results['findings']['network_analysis'] = await self._extract_network_analysis(dynamic_results)
            except Exception as e:
                self.logger.error(f"Dynamic analysis failed: {e}")
                results['findings']['dynamic_analysis'] = {'error': str(e)}
        else:
            results['findings']['dynamic_analysis'] = {
                'skipped': True,
                'reason': 'Sample deemed unsafe for sandboxing'
            }
        
        # Generate timeline events
        results['timeline_events'] = await self._generate_timeline_events(results['findings'])
        
        # Calculate threat score
        results['threat_score'] = self._calculate_threat_score(results['findings'])
        results['severity'] = self._determine_severity(results['threat_score'])
        
        # Generate recommendations
        results['recommendations'] = await self._generate_recommendations(results['findings'])
        
        results['analysis_end'] = datetime.now().isoformat()
        
        return results
    
    async def _get_sample_info(self, sample_path: Path) -> Dict[str, Any]:
        """Get basic information about the malware sample"""
        info = {
            'filename': sample_path.name,
            'size': sample_path.stat().st_size,
            'type': 'unknown',
            'hashes': {}
        }
        
        # Calculate hashes
        with open(sample_path, 'rb') as f:
            content = f.read()
            info['hashes']['md5'] = hashlib.md5(content).hexdigest()
            info['hashes']['sha1'] = hashlib.sha1(content).hexdigest()
            info['hashes']['sha256'] = hashlib.sha256(content).hexdigest()
            info['hashes']['ssdeep'] = ssdeep.hash(content)
        
        # Determine file type
        if content.startswith(b'MZ'):
            info['type'] = 'PE'
        elif content.startswith(b'\x7fELF'):
            info['type'] = 'ELF'
        elif content.startswith(b'\xfe\xed\xfa'):
            info['type'] = 'Mach-O'
        elif content.startswith(b'#!/'):
            info['type'] = 'Script'
        
        return info
    
    async def _static_analysis(self, sample_path: Path) -> Dict[str, Any]:
        """Perform static analysis on the malware sample"""
        static_results = {
            'file_properties': {},
            'imports': [],
            'exports': [],
            'sections': [],
            'strings': [],
            'yara_matches': [],
            'certificates': [],
            'resources': []
        }
        
        with open(sample_path, 'rb') as f:
            content = f.read()
        
        # YARA scanning
        matches = self.yara_rules.match(data=content)
        for match in matches:
            static_results['yara_matches'].append({
                'rule': match.rule,
                'namespace': match.namespace,
                'tags': match.tags,
                'meta': match.meta
            })
        
        # PE file analysis
        if content.startswith(b'MZ'):
            try:
                pe = pefile.PE(data=content)
                
                # File properties
                static_results['file_properties'] = {
                    'machine': hex(pe.FILE_HEADER.Machine),
                    'timestamp': datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp).isoformat(),
                    'characteristics': hex(pe.FILE_HEADER.Characteristics),
                    'subsystem': pe.OPTIONAL_HEADER.Subsystem if hasattr(pe, 'OPTIONAL_HEADER') else None,
                    'dll': pe.is_dll(),
                    'driver': pe.is_driver()
                }
                
                # Imports
                if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                    for entry in pe.DIRECTORY_ENTRY_IMPORT:
                        dll_name = entry.dll.decode('utf-8', errors='ignore')
                        imports = []
                        for imp in entry.imports:
                            if imp.name:
                                imports.append(imp.name.decode('utf-8', errors='ignore'))
                            else:
                                imports.append(f"Ordinal: {imp.ordinal}")
                        
                        static_results['imports'].append({
                            'dll': dll_name,
                            'functions': imports[:50]  # Limit
                        })
                
                # Exports
                if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
                        if exp.name:
                            static_results['exports'].append(
                                exp.name.decode('utf-8', errors='ignore')
                            )
                
                # Sections
                for section in pe.sections:
                    section_info = {
                        'name': section.Name.decode('utf-8', errors='ignore').strip('\x00'),
                        'virtual_address': hex(section.VirtualAddress),
                        'virtual_size': section.Misc_VirtualSize,
                        'raw_size': section.SizeOfRawData,
                        'entropy': section.get_entropy(),
                        'characteristics': hex(section.Characteristics)
                    }
                    
                    # High entropy might indicate packing/encryption
                    if section_info['entropy'] > 7.0:
                        section_info['suspicious'] = 'High entropy - possibly packed/encrypted'
                    
                    static_results['sections'].append(section_info)
                
                # Resources
                if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
                    static_results['resources'] = self._extract_resources(pe)
                
                pe.close()
                
            except Exception as e:
                self.logger.error(f"PE analysis error: {e}")
        
        # ELF file analysis
        elif content.startswith(b'\x7fELF'):
            try:
                with open(sample_path, 'rb') as f:
                    elf = ELFFile(f)
                    
                    static_results['file_properties'] = {
                        'class': elf.header['e_ident']['EI_CLASS'],
                        'machine': elf.header['e_machine'],
                        'type': elf.header['e_type'],
                        'entry_point': hex(elf.header['e_entry'])
                    }
                    
                    # Sections
                    for section in elf.iter_sections():
                        static_results['sections'].append({
                            'name': section.name,
                            'type': section['sh_type'],
                            'address': hex(section['sh_addr']),
                            'size': section['sh_size']
                        })
                        
            except Exception as e:
                self.logger.error(f"ELF analysis error: {e}")
        
        # Extract strings
        strings = await self._extract_strings(content)
        static_results['strings'] = self._analyze_strings(strings)
        
        return static_results
    
    def _extract_resources(self, pe) -> List[Dict]:
        """Extract resources from PE file"""
        resources = []
        
        def extract_resource_data(entry, level=0):
            if hasattr(entry, 'data'):
                return {
                    'type': entry.name if hasattr(entry, 'name') else 'Unknown',
                    'size': len(entry.data),
                    'entropy': self._calculate_entropy(entry.data)
                }
            elif hasattr(entry, 'directory'):
                for res in entry.directory.entries:
                    result = extract_resource_data(res, level + 1)
                    if result:
                        resources.append(result)
        
        try:
            for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                extract_resource_data(entry)
        except:
            pass
            
        return resources
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy of data"""
        import math
        from collections import Counter
        
        if not data:
            return 0
        
        counts = Counter(data)
        length = len(data)
        
        entropy = 0
        for count in counts.values():
            probability = count / length
            if probability > 0:
                entropy -= probability * math.log2(probability)
        
        return entropy
    
    async def _extract_strings(self, content: bytes) -> List[str]:
        """Extract printable strings from binary"""
        import string
        
        strings = []
        current_string = []
        min_length = 4
        
        for byte in content:
            if chr(byte) in string.printable:
                current_string.append(chr(byte))
            else:
                if len(current_string) >= min_length:
                    strings.append(''.join(current_string))
                current_string = []
        
        if len(current_string) >= min_length:
            strings.append(''.join(current_string))
        
        return strings
    
    def _analyze_strings(self, strings: List[str]) -> Dict[str, List[str]]:
        """Analyze extracted strings for interesting patterns"""
        categorized = {
            'urls': [],
            'ips': [],
            'emails': [],
            'registry_keys': [],
            'file_paths': [],
            'commands': [],
            'crypto': [],
            'suspicious': []
        }
        
        import re
        
        patterns = {
            'urls': re.compile(r'https?://[^\s]+'),
            'ips': re.compile(r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'),
            'emails': re.compile(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'),
            'registry_keys': re.compile(r'HKEY_[A-Z_]+\\[\\A-Za-z0-9_]+'),
            'file_paths': re.compile(r'[A-Za-z]:\\[^<>:"|?*\n\r]+'),
            'commands': re.compile(r'(cmd|powershell|bash|sh)\.exe')
        }
        
        suspicious_keywords = [
            'password', 'decrypt', 'encrypt', 'ransom', 'bitcoin',
            'wallet', 'victim', 'infected', 'payload', 'backdoor',
            'keylog', 'screenshot', 'webcam', 'microphone'
        ]
        
        for string in strings[:1000]:  # Limit analysis
            # Check patterns
            for category, pattern in patterns.items():
                if pattern.search(string):
                    categorized[category].append(string)
            
            # Check suspicious keywords
            string_lower = string.lower()
            for keyword in suspicious_keywords:
                if keyword in string_lower:
                    categorized['suspicious'].append(string)
                    break
        
        # Limit results
        for category in categorized:
            categorized[category] = categorized[category][:50]
        
        return categorized
    
    async def _code_analysis(self, sample_path: Path) -> Dict[str, Any]:
        """Analyze code structure and functionality"""
        code_analysis = {
            'functions': [],
            'api_calls': [],
            'control_flow': {},
            'crypto_usage': [],
            'obfuscation': []
        }
        
        with open(sample_path, 'rb') as f:
            content = f.read()
        
        # Disassemble code
        if content.startswith(b'MZ'):
            # PE file
            try:
                disasm_results = await self.disassembler.disassemble_pe(content)
                
                # Extract function information
                code_analysis['functions'] = disasm_results.get('functions', [])[:100]
                
                # Extract API calls
                code_analysis['api_calls'] = self._extract_api_calls(disasm_results)
                
                # Detect crypto usage
                code_analysis['crypto_usage'] = self._detect_crypto_usage(disasm_results)
                
                # Detect obfuscation
                code_analysis['obfuscation'] = self._detect_obfuscation(disasm_results)
                
            except Exception as e:
                self.logger.error(f"Code analysis error: {e}")
        
        return code_analysis
    
    def _extract_api_calls(self, disasm_results: Dict) -> List[Dict]:
        """Extract and categorize API calls"""
        api_calls = []
        
        # Categorize APIs by functionality
        api_categories = {
            'process': ['CreateProcess', 'OpenProcess', 'TerminateProcess', 'CreateRemoteThread'],
            'file': ['CreateFile', 'ReadFile', 'WriteFile', 'DeleteFile', 'MoveFile'],
            'registry': ['RegOpenKey', 'RegSetValue', 'RegQueryValue', 'RegDeleteKey'],
            'network': ['WSAStartup', 'socket', 'connect', 'send', 'recv', 'InternetOpen'],
            'crypto': ['CryptEncrypt', 'CryptDecrypt', 'CryptGenKey', 'CryptHashData'],
            'injection': ['VirtualAllocEx', 'WriteProcessMemory', 'SetThreadContext'],
            'stealth': ['SetFileAttributes', 'SetWindowsHookEx', 'GetAsyncKeyState']
        }
        
        # Extract calls from disassembly
        for func in disasm_results.get('functions', []):
            for call in func.get('calls', []):
                api_name = call.get('target', '')
                
                # Categorize the API
                category = 'other'
                for cat, apis in api_categories.items():
                    if any(api in api_name for api in apis):
                        category = cat
                        break
                
                api_calls.append({
                    'name': api_name,
                    'category': category,
                    'address': call.get('address', '')
                })
        
        return api_calls[:200]  # Limit
    
    def _detect_crypto_usage(self, disasm_results: Dict) -> List[Dict]:
        """Detect cryptographic operations"""
        crypto_indicators = []
        
        # Crypto-related constants and patterns
        crypto_constants = {
            0x67452301: 'MD5/SHA init value',
            0xEFCDAB89: 'MD5/SHA init value',
            0x98BADCFE: 'MD5/SHA init value',
            0x10325476: 'MD5 init value',
            0x6A09E667: 'SHA-256 init value',
            0xBB67AE85: 'SHA-256 init value'
        }
        
        # Check for crypto constants in code
        for func in disasm_results.get('functions', []):
            for inst in func.get('instructions', []):
                if inst.get('mnemonic') == 'mov' and 'immediate' in inst:
                    imm_value = inst['immediate']
                    if imm_value in crypto_constants:
                        crypto_indicators.append({
                            'type': 'constant',
                            'value': hex(imm_value),
                            'description': crypto_constants[imm_value],
                            'address': inst['address']
                        })
        
        return crypto_indicators
    
    def _detect_obfuscation(self, disasm_results: Dict) -> List[Dict]:
        """Detect code obfuscation techniques"""
        obfuscation_indicators = []
        
        # Check for obfuscation patterns
        for func in disasm_results.get('functions', []):
            # Check for junk code patterns
            junk_count = 0
            total_instructions = len(func.get('instructions', []))
            
            for inst in func.get('instructions', []):
                # Common junk instructions
                if inst.get('mnemonic') in ['nop', 'xchg eax, eax', 'mov edi, edi']:
                    junk_count += 1
            
            if total_instructions > 0 and junk_count / total_instructions > 0.2:
                obfuscation_indicators.append({
                    'type': 'junk_code',
                    'function': func.get('name', 'Unknown'),
                    'junk_ratio': junk_count / total_instructions
                })
        
        return obfuscation_indicators
    
    async def _anti_analysis_detection(self, sample_path: Path) -> Dict[str, Any]:
        """Detect anti-analysis techniques"""
        anti_analysis = {
            'anti_debug': [],
            'anti_vm': [],
            'anti_sandbox': [],
            'packing': [],
            'timing_checks': []
        }
        
        with open(sample_path, 'rb') as f:
            content = f.read()
        
        # Check for anti-debugging techniques
        anti_debug_apis = [
            b'IsDebuggerPresent',
            b'CheckRemoteDebuggerPresent',
            b'NtQueryInformationProcess',
            b'OutputDebugString',
            b'NtSetInformationThread'
        ]
        
        for api in anti_debug_apis:
            if api in content:
                anti_analysis['anti_debug'].append({
                    'technique': 'API Call',
                    'api': api.decode('utf-8'),
                    'description': f"Uses {api.decode('utf-8')} to detect debuggers"
                })
        
        # Check for anti-VM techniques
        vm_artifacts = [
            b'VMware',
            b'VirtualBox',
            b'QEMU',
            b'Bochs',
            b'Xen',
            b'Virtual HD',
            b'VBOX'
        ]
        
        for artifact in vm_artifacts:
            if artifact in content:
                anti_analysis['anti_vm'].append({
                    'technique': 'Artifact Check',
                    'artifact': artifact.decode('utf-8'),
                    'description': f"Checks for {artifact.decode('utf-8')} to detect VMs"
                })
        
        # Check for packing
        if content.startswith(b'MZ'):
            try:
                pe = pefile.PE(data=content)
                
                # Check section characteristics for packing indicators
                for section in pe.sections:
                    entropy = section.get_entropy()
                    if entropy > 7.0:
                        anti_analysis['packing'].append({
                            'section': section.Name.decode('utf-8', errors='ignore').strip('\x00'),
                            'entropy': entropy,
                            'description': 'High entropy suggests packing/encryption'
                        })
                
                pe.close()
                
            except:
                pass
        
        return anti_analysis
    
    async def _similarity_analysis(self, sample_path: Path) -> Dict[str, Any]:
        """Analyze similarity to known malware"""
        similarity = {
            'ssdeep_matches': [],
            'imphash_matches': [],
            'similar_samples': []
        }
        
        with open(sample_path, 'rb') as f:
            content = f.read()
        
        # Calculate fuzzy hash
        sample_ssdeep = ssdeep.hash(content)
        
        # Compare with known malware database (simplified)
        # In real implementation, this would query a malware database
        
        # Calculate import hash for PE files
        if content.startswith(b'MZ'):
            try:
                pe = pefile.PE(data=content)
                imphash = pe.get_imphash()
                similarity['imphash'] = imphash
                pe.close()
            except:
                pass
        
        return similarity
    
    def _is_safe_to_sandbox(self, static_findings: Dict) -> bool:
        """Determine if sample is safe to run in sandbox"""
        # Check for destructive capabilities
        if 'static_analysis' in static_findings:
            dangerous_apis = [
                'DeleteFile', 'FormatDrive', 'SystemShutdown',
                'TerminateProcess', 'RegDeleteKey'
            ]
            
            api_calls = static_findings['static_analysis'].get('imports', [])
            for dll_import in api_calls:
                for api in dll_import.get('functions', []):
                    if any(dangerous in api for dangerous in dangerous_apis):
                        return False
        
        # Check YARA matches for known destructive malware
        if 'static_analysis' in static_findings:
            for match in static_findings['static_analysis'].get('yara_matches', []):
                if 'wiper' in match.get('tags', []) or 'destructive' in match.get('tags', []):
                    return False
        
        return True
    
    async def _dynamic_analysis(self, sample_path: Path) -> Dict[str, Any]:
        """Perform dynamic analysis in sandbox"""
        self.logger.info("Starting sandbox analysis")
        
        # Submit to sandbox
        sandbox_results = await self.sandbox.analyze(sample_path, timeout=300)
        
        return sandbox_results
    
    async def _extract_behavioral_analysis(self, dynamic_results: Dict) -> Dict[str, Any]:
        """Extract behavioral patterns from dynamic analysis"""
        behavioral = {
            'process_activity': [],
            'file_activity': [],
            'registry_activity': [],
            'persistence_mechanisms': [],
            'evasion_techniques': []
        }
        
        if not dynamic_results or 'error' in dynamic_results:
            return behavioral
        
        # Extract process activity
        for proc in dynamic_results.get('processes', []):
            behavioral['process_activity'].append({
                'name': proc['name'],
                'pid': proc['pid'],
                'parent_pid': proc['parent_pid'],
                'command_line': proc.get('command_line', ''),
                'created_processes': proc.get('children', [])
            })
        
        # Extract file activity
        for file_op in dynamic_results.get('file_operations', []):
            behavioral['file_activity'].append({
                'operation': file_op['type'],
                'path': file_op['path'],
                'timestamp': file_op['timestamp']
            })
        
        # Extract registry activity
        for reg_op in dynamic_results.get('registry_operations', []):
            behavioral['registry_activity'].append({
                'operation': reg_op['type'],
                'key': reg_op['key'],
                'value': reg_op.get('value', ''),
                'data': reg_op.get('data', '')
            })
            
            # Check for persistence
            persistence_keys = [
                'CurrentVersion\\Run',
                'CurrentVersion\\RunOnce',
                'CurrentControlSet\\Services',
                'CurrentVersion\\Winlogon'
            ]
            
            for persist_key in persistence_keys:
                if persist_key in reg_op['key']:
                    behavioral['persistence_mechanisms'].append({
                        'type': 'registry_autostart',
                        'key': reg_op['key'],
                        'value': reg_op.get('value', '')
                    })
        
        return behavioral
    
    async def _extract_network_analysis(self, dynamic_results: Dict) -> Dict[str, Any]:
        """Extract network behavior from dynamic analysis"""
        network = {
            'connections': [],
            'dns_queries': [],
            'http_requests': [],
            'c2_indicators': [],
            'data_exfiltration': []
        }
        
        if not dynamic_results or 'error' in dynamic_results:
            return network
        
        # Extract connections
        for conn in dynamic_results.get('network_connections', []):
            network['connections'].append({
                'protocol': conn['protocol'],
                'local_address': f"{conn['local_ip']}:{conn['local_port']}",
                'remote_address': f"{conn['remote_ip']}:{conn['remote_port']}",
                'state': conn.get('state', 'unknown')
            })
            
            # Check for C2 patterns
            if conn['remote_port'] in [443, 8443, 4444, 5555]:
                network['c2_indicators'].append({
                    'type': 'suspicious_port',
                    'address': f"{conn['remote_ip']}:{conn['remote_port']}",
                    'description': f"Connection to suspicious port {conn['remote_port']}"
                })
        
        # Extract DNS queries
        for dns in dynamic_results.get('dns_queries', []):
            network['dns_queries'].append({
                'domain': dns['domain'],
                'type': dns['type'],
                'answer': dns.get('answer', '')
            })
            
            # Check for DGA patterns
            if len(dns['domain']) > 20 and '.' in dns['domain']:
                domain_part = dns['domain'].split('.')[0]
                if self._calculate_entropy(domain_part.encode()) > 3.5:
                    network['c2_indicators'].append({
                        'type': 'dga_domain',
                        'domain': dns['domain'],
                        'description': 'Possible DGA-generated domain'
                    })
        
        # Extract HTTP requests
        for http in dynamic_results.get('http_requests', []):
            network['http_requests'].append({
                'method': http['method'],
                'url': http['url'],
                'user_agent': http.get('user_agent', ''),
                'response_code': http.get('response_code', 0)
            })
        
        return network
    
    async def _generate_timeline_events(self, findings: Dict) -> List[Dict]:
        """Generate timeline events from malware analysis"""
        events = []
        
        # Add YARA detection events
        if 'static_analysis' in findings:
            for match in findings['static_analysis'].get('yara_matches', []):
                events.append({
                    'timestamp': datetime.now().isoformat(),
                    'type': 'malware_detection',
                    'description': f"Malware detected: {match['rule']}",
                    'severity': match.get('meta', {}).get('severity', 'high'),
                    'data': match
                })
        
        # Add behavioral events
        if 'behavioral_analysis' in findings:
            for persistence in findings['behavioral_analysis'].get('persistence_mechanisms', []):
                events.append({
                    'timestamp': datetime.now().isoformat(),
                    'type': 'persistence_mechanism',
                    'description': f"Persistence mechanism: {persistence['type']}",
                    'severity': 'high',
                    'data': persistence
                })
        
        # Add C2 communication events
        if 'network_analysis' in findings:
            for c2 in findings['network_analysis'].get('c2_indicators', []):
                events.append({
                    'timestamp': datetime.now().isoformat(),
                    'type': 'c2_communication',
                    'description': f"C2 indicator: {c2['type']}",
                    'severity': 'critical',
                    'data': c2
                })
        
        return sorted(events, key=lambda x: x['timestamp'])
    
    def _calculate_threat_score(self, findings: Dict) -> int:
        """Calculate threat score based on findings"""
        score = 0
        
        # Static analysis scoring
        if 'static_analysis' in findings:
            # YARA matches
            for match in findings['static_analysis'].get('yara_matches', []):
                if 'ransomware' in match.get('tags', []):
                    score += 50
                elif 'trojan' in match.get('tags', []):
                    score += 40
                elif 'packer' in match.get('tags', []):
                    score += 20
                else:
                    score += 30
            
            # Suspicious imports
            imports = findings['static_analysis'].get('imports', [])
            suspicious_dlls = ['ws2_32.dll', 'wininet.dll', 'urlmon.dll', 'crypt32.dll']
            for dll_import in imports:
                if any(sus_dll in dll_import.get('dll', '').lower() for sus_dll in suspicious_dlls):
                    score += 10
        
        # Anti-analysis techniques
        if 'anti_analysis_detection' in findings:
            if findings['anti_analysis_detection'].get('anti_debug'):
                score += 20
            if findings['anti_analysis_detection'].get('anti_vm'):
                score += 20
            if findings['anti_analysis_detection'].get('packing'):
                score += 30
        
        # Behavioral analysis
        if 'behavioral_analysis' in findings:
            if findings['behavioral_analysis'].get('persistence_mechanisms'):
                score += 30
            if len(findings['behavioral_analysis'].get('file_activity', [])) > 50:
                score += 20
        
        # Network analysis
        if 'network_analysis' in findings:
            if findings['network_analysis'].get('c2_indicators'):
                score += 40
            if findings['network_analysis'].get('data_exfiltration'):
                score += 50
        
        return min(score, 100)  # Cap at 100
    
    def _determine_severity(self, threat_score: int) -> str:
        """Determine severity based on threat score"""
        if threat_score >= 80:
            return 'critical'
        elif threat_score >= 60:
            return 'high'
        elif threat_score >= 40:
            return 'medium'
        elif threat_score >= 20:
            return 'low'
        else:
            return 'info'
    
    async def _generate_recommendations(self, findings: Dict) -> List[str]:
        """Generate recommendations based on analysis"""
        recommendations = []
        
        # Check for ransomware
        if 'static_analysis' in findings:
            for match in findings['static_analysis'].get('yara_matches', []):
                if 'ransomware' in match.get('tags', []):
                    recommendations.append("CRITICAL: Ransomware detected. Isolate affected systems immediately.")
                    recommendations.append("Implement ransomware-specific incident response procedures.")
                    recommendations.append("Check backups and prepare for potential recovery operations.")
                    break
        
        # Check for C2 communication
        if 'network_analysis' in findings:
            if findings['network_analysis'].get('c2_indicators'):
                recommendations.append("Block identified C2 servers at firewall/proxy level.")
                recommendations.append("Hunt for similar indicators across the network.")
                recommendations.append("Check for lateral movement from infected host.")
        
        # Check for persistence
        if 'behavioral_analysis' in findings:
            if findings['behavioral_analysis'].get('persistence_mechanisms'):
                recommendations.append("Remove identified persistence mechanisms.")
                recommendations.append("Monitor for re-infection attempts.")
                recommendations.append("Scan for similar persistence across environment.")
        
        # General recommendations
        recommendations.append("Update antivirus signatures with sample hash.")
        recommendations.append("Create network and host-based indicators for detection.")
        recommendations.append("Document all findings for threat intelligence sharing.")
        
        return recommendations
    
    async def _cleanup(self):
        """Cleanup agent resources"""
        if self.sandbox:
            await self.sandbox.cleanup()
        if self.disassembler:
            await self.disassembler.cleanup()